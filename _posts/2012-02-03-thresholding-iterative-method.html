---
layout: post
title: Thresholding (Iterative Method)
date: '2012-02-03T16:58:00.001+08:00'
author: Handra
tags:
- Algorithm and Data Structure
- Computer Vision
modified_time: '2012-02-03T16:58:06.540+08:00'
blogger_id: tag:blogger.com,1999:blog-6088975468803563517.post-7830694890922721263
blogger_orig_url: https://handracs.blogspot.com/2012/02/thresholding-iterative-method.html
---

<span class="Apple-style-span" style="font-family: Verdana, sans-serif;">Thresholding is inevitably one of the mostly used image processing algorithm. It is told as the simplest method of image segmentation.</span><br /><span class="Apple-style-span" style="font-family: Verdana, sans-serif;"><br /></span><br /><span class="Apple-style-span" style="font-family: Verdana, sans-serif;">In this post, I want to introduce one thresholding algorithm that is powerful enough yet simple enough to implement. The method called "Iterative Method." Below is the step by step used in the algorithm:</span><br /><span class="Apple-style-span" style="font-family: Verdana, sans-serif;"></span><br /><ol style="line-height: 1.5em; list-style-image: none; margin-bottom: 0px; margin-left: 3.2em; margin-right: 0px; margin-top: 0.3em; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;"><li style="margin-bottom: 0.1em;"><span class="Apple-style-span" style="font-family: Verdana, sans-serif;">An initial threshold (T) is chosen, this can be done randomly or according to any other method desired.</span></li><li style="margin-bottom: 0.1em;"><span class="Apple-style-span" style="font-family: Verdana, sans-serif;">The image is segmented into object and background pixels as described above, creating two sets:<ol style="line-height: 1.5em; list-style-image: none; margin-bottom: 0px; margin-left: 3.2em; margin-right: 0px; margin-top: 0.3em; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;"><li style="margin-bottom: 0.1em;"><span class="texhtml" dir="ltr" style="white-space: nowrap;"><i>G</i><sub style="line-height: 1em;">1</sub></span>&nbsp;= {f(m,n):f(m,n)&gt;T} (object pixels)</li><li style="margin-bottom: 0.1em;"><span class="texhtml" dir="ltr" style="white-space: nowrap;"><i>G</i><sub style="line-height: 1em;">2</sub></span>&nbsp;= {f(m,n):f(m,n)<img alt="\le" class="tex" src="http://upload.wikimedia.org/wikipedia/en/math/4/9/d/49dc1443f33cf63082d6e193dd2af78f.png" style="border-bottom-style: none; border-color: initial; border-left-style: none; border-right-style: none; border-top-style: none; border-width: initial; vertical-align: middle;" />T} (background pixels) (note, f(m,n) is the value of the pixel located in the&nbsp;<span class="texhtml" dir="ltr" style="white-space: nowrap;"><i>m</i><sup style="line-height: 1em;"><i>t</i><i>h</i></sup></span>&nbsp;column,&nbsp;<span class="texhtml" dir="ltr" style="white-space: nowrap;"><i>n</i><sup style="line-height: 1em;"><i>t</i><i>h</i></sup></span>&nbsp;row)</li></ol></span></li><li style="margin-bottom: 0.1em;"><span class="Apple-style-span" style="font-family: Verdana, sans-serif;">The average of each set is computed.<ol style="line-height: 1.5em; list-style-image: none; margin-bottom: 0px; margin-left: 3.2em; margin-right: 0px; margin-top: 0.3em; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;"><li style="margin-bottom: 0.1em;"><span class="texhtml" dir="ltr" style="white-space: nowrap;"><i>m</i><sub style="line-height: 1em;">1</sub></span>&nbsp;= average value of&nbsp;<span class="texhtml" dir="ltr" style="white-space: nowrap;"><i>G</i><sub style="line-height: 1em;">1</sub></span></li><li style="margin-bottom: 0.1em;"><span class="texhtml" dir="ltr" style="white-space: nowrap;"><i>m</i><sub style="line-height: 1em;">2</sub></span>&nbsp;= average value of&nbsp;<span class="texhtml" dir="ltr" style="white-space: nowrap;"><i>G</i><sub style="line-height: 1em;">2</sub></span></li></ol></span></li><li style="margin-bottom: 0.1em;"><span class="Apple-style-span" style="font-family: Verdana, sans-serif;">A new threshold is created that is the average of&nbsp;<span class="texhtml" dir="ltr" style="white-space: nowrap;"><i>m</i><sub style="line-height: 1em;">1</sub></span>&nbsp;and&nbsp;<span class="texhtml" dir="ltr" style="white-space: nowrap;"><i>m</i><sub style="line-height: 1em;">2</sub></span><ol style="line-height: 1.5em; list-style-image: none; margin-bottom: 0px; margin-left: 3.2em; margin-right: 0px; margin-top: 0.3em; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;"><li style="margin-bottom: 0.1em;">Tâ€™ = (<span class="texhtml" dir="ltr" style="white-space: nowrap;"><i>m</i><sub style="line-height: 1em;">1</sub></span>&nbsp;+&nbsp;<span class="texhtml" dir="ltr" style="white-space: nowrap;"><i>m</i><sub style="line-height: 1em;">2</sub></span>)/2</li></ol></span></li><li style="margin-bottom: 0.1em;"><span class="Apple-style-span" style="font-family: Verdana, sans-serif;">Go back to step two, now using the new threshold computed in step four, keep repeating until the new threshold matches the one before it (i.e. until convergence has been reached).</span></li></ol><div><span class="Apple-style-span" style="font-family: Verdana, sans-serif;"><span class="Apple-style-span" style="line-height: 24px;"><br /></span></span></div><div><span class="Apple-style-span" style="font-family: Verdana, sans-serif;"><span class="Apple-style-span" style="line-height: 24px;">Posted below is the Java source code I use to implement the algorithm.</span></span></div><pre>/*<br />    Method Name: _calculateThreshold<br />    Params     : image: BufferedImage -&gt; Image representation in Grayscale colour space<br />    Return     : double -&gt; The computed threshold value<br />*/<br />private double _calculateThreshold ( BufferedImage image )<br />{<br />    double totalThreshold = 0;<br />    double averageThreshold = 0;<br /><br />    /* Get the image width and height */<br />    int width = image.getWidth ();<br />    int height = image.getHeight ();<br /></pre><pre>    /* Get the image data */<br />    Raster data = image.getData ();<br />    double[] pixel = new double[ width * height * 3 ];<br /><br />    data.getPixels ( 0 , 0 , width , height , pixel );<br /><br />    /*<br />        Calculate threshold value as initial threshold by computing average threshold value<br />    */<br />    for ( int row = 0 ; row &lt; height ; row ++ )<br />        for ( int col = 0 ; col &lt; width ; col ++ )<br />        {<br />            int index = col * 3 + row * width * 3;<br />            double gray = ( 0.3 * pixel[index] + 0.59 * pixel[index + 1] + 0.11 * pixel[index + 2] );<br /><br />            totalThreshold += gray;<br />        }<br /><br />    averageThreshold = totalThreshold / ( double ) ( width * height );<br /><br />    /* Begin the iterative method */<br />    while ( true )<br />    {<br />        float g1 = 0;<br />        float g2 = 0;<br />        int g1Count = 0;<br />        int g2Count = 0;<br /><br />        for ( int row = 0 ; row &lt; height ; row ++ )<br />        {<br />            for ( int col = 0 ; col &lt; width ; col ++ )<br />            {<br />                int index = col * 3 + row * width * 3;<br />                double gray = ( 0.3 * pixel[index] + 0.59 * pixel[index + 1] + 0.11 * pixel[index + 2] );<br /><br />                if ( gray &gt; averageThreshold )<br />                {<br />                    g1 += gray;<br />                    g1Count ++;<br />                }<br />                else<br />                {<br />                    g2 += gray;<br />                    g2Count ++;<br />                }<br />            }<br />        }<br /><br />        double m1 = g1 / ( double ) g1Count;<br />        double m2 = g2 / ( double ) g2Count;<br />        double m = ( m1 + m2 ) / 2;<br /><br />        if ( averageThreshold == m )<br />            break;<br />        else<br />            averageThreshold = m;<br />    }<br /><br />    /* Return the computed threshold value */<br />    return averageThreshold;<br />}<br /></pre>Method below shows how we use the computed threshold value to convert our grayscale image to B/W (or so called binary image). <br /><pre>/*<br />    Method Name: _convertToBW<br />    Params     : image: BufferedImage -&gt; Coloured image representation<br />    Return     : BufferedImage -&gt; The B/W image<br />*/<br />private BufferedImage _convertToBW ( BufferedImage image )<br />{<br />    /* Create a buffer to store the result */<br />    BufferedImage result = new BufferedImage ( image.getWidth () , image.getHeight () , BufferedImage.TYPE_INT_RGB );<br /><br />    /* Get the image data */<br />    int width = image.getWidth ();<br />    int height = image.getHeight ();<br /><br />    /* Convert the image to grayscale */<br />    ColorConvertOp op = new ColorConvertOp ( ColorSpace.getInstance ( ColorSpace.CS_GRAY ) , null );<br />    op.filter ( image , result );<br /><br />    /* Calculate the average threshold */<br />    double averageThreshold = this._calculateThreshold ( result );<br /><br />    /* Convert the image to B/W colour space */<br />    WritableRaster data = result.getRaster ();<br />    double[] pixel = new double[ width * height * 3 ];<br /><br />    data.getPixels ( 0 , 0 , width , height , pixel );<br /><br />    for ( int row = 0 ; row &lt; height ; row ++ )<br />    {<br />        for ( int col = 0 ; col &lt; width ; col ++ )<br />        {<br />            int index = col * 3 + row * width * 3;<br />            double gray = ( 0.3 * pixel[index] + 0.59 * pixel[index + 1] + 0.11 * pixel[index + 2] );<br /><br />            /* <br />                If the intensity is less than the given threshold, then make it black.<br />                Otherwise, make it white<br />             */<br />            if ( gray &lt; averageThreshold )<br />                data.setPixel ( col , row , new int[]<br />                    {<br />                        0 , 0 , 0<br />                    } );<br />            else<br />                data.setPixel ( col , row , new int[]<br />                    {<br />                        255 , 255 , 255<br />                    } );<br />        }<br />    }<br /><br />    /* Return the result */<br />    return result;<br />}<br /></pre>Hope you find this post useful.