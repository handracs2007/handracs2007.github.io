---
layout: post
title: Digital Signing with Java
date: '2019-07-21T09:35:00.000+08:00'
author: Handra
tags:
- Java
- Computer Security
modified_time: '2019-07-21T14:39:25.805+08:00'
thumbnail: https://1.bp.blogspot.com/-ceet81ps8jM/XTQEVUDip-I/AAAAAAAAgt8/dpyqE20WZuwRJqziC_UFsZdIlMhDGiXSQCEwYBhgL/s72-c/digsignwithjava_genkeypair.png
blogger_id: tag:blogger.com,1999:blog-6088975468803563517.post-2082660333779867962
blogger_orig_url: https://handracs.blogspot.com/2019/07/digital-signing-with-java.html
---

<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Orange_blue_digital_signature_en.svg/800px-Orange_blue_digital_signature_en.svg.png" imageanchor="1" style="margin-left: auto; margin-right: auto; text-align: center;"><img border="0" data-original-height="508" data-original-width="800" height="406" src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Orange_blue_digital_signature_en.svg/800px-Orange_blue_digital_signature_en.svg.png" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Digital Signature<br />Source: <a href="https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Orange_blue_digital_signature_en.svg/800px-Orange_blue_digital_signature_en.svg.png" target="_blank">Wikipedia</a></td></tr></tbody></table><br />In today's post, we are going to see how easy it is to do digital signing using Java programming language. Java has provided libraries that you can use out of the box to produce digital signature. Let's get started.<br /><h2>A little bit of theory</h2><div>For those of you who do not know yet about digital signature, this is basically a process that ensures that the content that you sent has not been altered in any way. Digital signature is one of the most important things to do in this digital world. Without it, it will be hard to verify data integrity.</div><div><br /></div><h3>Relationship with Hashing</h3><div>At this stage, one must have noticed that to check data integrity, you can actually use a <a href="https://www.handracs.info/2018/12/hashing-and-java-implementation.html" target="_blank">hashing</a> algorithm. For example, when you download a file from the internet, they usually provide the hash (be it MD5 or SHA1 or higher) for you to check the integrity of the downloaded file.</div><div><br /></div><div>Although this is true, digital signing actually provides you with more than just a data integrity. Digital signing has tight integration with <a href="https://www.handracs.info/2012/04/public-key-infrastructure-fundamental.html" target="_blank">PKI (Public Key Infrastructure)</a>. In order to perform digital signing, you need to have a pair of keys, called Public Key and Private Key. Given that public-private keypair is owned only by one person, one cannot deny that he/she performed the digital signature (so called non-repudiation).</div><div><br /></div><div>In practice, digital signing involves TWO (2) concepts of security, named hashing and encryption. Hence, you will later see that the digital signing algorithm indeed is a combination of hashing algorithm and asymmetric key algorithm.</div><div><br /></div><h3>How it works</h3><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://upload.wikimedia.org/wikipedia/commons/thumb/7/78/Private_key_signing.svg/800px-Private_key_signing.svg.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="782" data-original-width="800" height="312" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/78/Private_key_signing.svg/800px-Private_key_signing.svg.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Digital Signing Concept<br />Source: <a href="https://upload.wikimedia.org/wikipedia/commons/thumb/7/78/Private_key_signing.svg/800px-Private_key_signing.svg.png" target="_blank">Wikipedia</a></td></tr></tbody></table><div>The image above depicts the simple and usual use case of digital signing. Let's say there are TWO (2) people, namely Alice and Bob. Alice wants to say hello to Bob via a message, and Alice wants to ensure that the message is not tampered during the transit to Bob. Alice will perform digital signing using her private key.</div><div><br /></div><div>Why you would ask? Why not use Alice's public key? To answer this, we need to remember back the concept of non-repudiation briefly mentioned above. Public Key (as the name suggests), can be distributed to anyone in the world, because it's public. Private key though, on the other hand, can only be kept by the key owner. Hence, when Alice performs digital signing using her private key, we can ensure that the message does come from Alice.</div><div><br /></div><div>Now, once Bob receives the message, Bob has to ensure that the message has not been tampered. Bob verifies the digital signature against the plain message he receives from Alice using Alice's public key. If the verification successful, this proves that the message indeed come from Alice and has not been tampered during transit to Bob.</div><div><br /></div><h2>Java implementation</h2><h3>Keypair generation</h3><div>We will start our first step of performing digital signing with keypair generation method. This method is used to generate a new keypair that will be used through the entire process of signing and verification. See below.<br /><div class="separator" style="clear: both; text-align: center;"></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-ceet81ps8jM/XTQEVUDip-I/AAAAAAAAgt8/dpyqE20WZuwRJqziC_UFsZdIlMhDGiXSQCEwYBhgL/s1600/digsignwithjava_genkeypair.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="246" data-original-width="625" src="https://1.bp.blogspot.com/-ceet81ps8jM/XTQEVUDip-I/AAAAAAAAgt8/dpyqE20WZuwRJqziC_UFsZdIlMhDGiXSQCEwYBhgL/s1600/digsignwithjava_genkeypair.png" /></a></div><br />I have created a new method named <b>generateKeyPair</b>. This method accepts TWO (2) parameters, which is the keypair algorithm and the length (or so called the key size).</div><div><br /></div><div>Generating keypair in Java involves initialising a class named <b>KeyPairGenerator</b>. You just need to provide the name of the algorithm to its <b>getInstance</b>&nbsp;method. It will return the appropriate instance of the <b>KeyPairGenerator</b>. There are some other overloading methods of the <b>getInstance</b>&nbsp;which allow you to provide different provider, however this is out of the scope of this post.</div><div><br /></div><div>Once you get the instance of the <b>KeyPairGenerator</b>, you need to tell the length of the key to be generated to this generator. This is as simple as calling the <b>initialize</b>&nbsp;method and passing in the key length required.</div><div><br /></div><div>Once the generator is set, simply call the <b>generateKeyPair</b>&nbsp;method and it will generate the keypair for you. Do take note that the higher the key size, the longer it takes to generate the keypair.</div><div><br /></div><h3>Signature generation</h3><div>Now that we have the method to generate keypair ready, let's create another method to perform the signing.<br /><div class="separator" style="clear: both; text-align: justify;"><a href="https://1.bp.blogspot.com/-EDWQ1Eu7YGY/XTQEVRzRTuI/AAAAAAAAgts/kDL2NKkJUpQa0RyhfIXUnKwdL027oPCvQCEwYBhgL/s1600/digsignwithjava_sign.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="277" data-original-width="704" src="https://1.bp.blogspot.com/-EDWQ1Eu7YGY/XTQEVRzRTuI/AAAAAAAAgts/kDL2NKkJUpQa0RyhfIXUnKwdL027oPCvQCEwYBhgL/s1600/digsignwithjava_sign.png" /></a></div><br /></div><div>The <b>sign</b>&nbsp;method above accepts few parameters:</div><div><ul><li>The key to be used for signing. As we have discussed above, we need the private key to do digital signing.</li><li>The plain text to be signed. From the above example, this is the string "Hello Bob."</li><li>The signing algorithm. This is the algorithm that will be used to perform the digital signing process.</li></ul><div>Just like keypair generation, the procedure to perform digital signing involves several simple steps. First, you need to get an instance of the class <b>Signature</b>&nbsp;by passing in the algorithm to its <b>getInstance</b>&nbsp;method. If the algorithm is recognised and correct, you will get the proper instance of the class <b>Signature</b>&nbsp;to perform the signing.</div></div><div><br /></div><div>Once we have the instance ready, we need to tell it which key to use to perform the signing. To do this, we need to call the method <b>initSign </b>of the <b>Signature</b>&nbsp;object and pass in the key that we are going to use to sign.</div><div><br /></div><div>The next step is to tell the class as well what is the data that we want to sign. To do this, we send in the byte of data to the <b>update </b>method. By now, you should have noticed that the parameter is in byte[] instead of String. This is because you pretty much can sign anything, not only String object. You can perform digital signature on binary files as well.</div><div><br /></div><div>Once everything is set up, you can simply call the <b>sign</b>&nbsp;method and it will perform the signing and return it to you as a byte array. As you know, byte array is not something that is easily representable to the end user. That's why, we usually encode the signature into more digestible string, such as to Hexadecimal or Base64. In the example above, I encoded the signature to base64 using the Base64 class that is provided by Java as well.</div><div><br /></div><h3>Signature verification</h3><div>Once we have the digital signature, the process is not complete without performing verification. Here, I created a method to perform digital signature verification.<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-VhUUn3nmSo8/XTQEWlinYOI/AAAAAAAAgt0/FYEnwPwPOOcP9exeZ4Dl18aybZScjKqNgCEwYBhgL/s1600/digsignwithjava_verify.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="217" data-original-width="754" src="https://1.bp.blogspot.com/-VhUUn3nmSo8/XTQEWlinYOI/AAAAAAAAgt0/FYEnwPwPOOcP9exeZ4Dl18aybZScjKqNgCEwYBhgL/s1600/digsignwithjava_verify.png" /></a></div><br />This method accepts several parameters:</div><div><ol><li>The key to be used for verification. As discussed above, we are going to use public key for verification.</li><li>The plain text that has been signed previously. In the above example, this is the "Hello Bob" string.</li><li>The algorithm for verification. This should be the same algorithm we used for signing.</li></ol><div>To perform digital signature verification, we are still using the same class <b>Signature</b>. The difference now is that, instead of calling the <b>initSign</b>&nbsp;method and sending the private key, we should call <b>initVerify</b>&nbsp;method and send the public key.</div></div><div><br /></div><div>We then need to tell the class what's the plain text to be checked against. To do this, we call the <b>update</b>&nbsp;method and passing in the plain data as the parameter.</div><div><br /></div><div>Once everything is ready, we simply just need to call the <b>verify</b>&nbsp;method, passing in the signature data. Notice that I decoded the signature first from base64 string using the built-in Base64 class. This is because during the signing, we encoded the signature using base64. This method returns boolean indicating whether or not the verification is successful. Obviously, <b>true</b>&nbsp;means the verification successful, and <b>false</b>&nbsp;otherwise.</div><div><br /></div><h3>Tying it up together</h3><div>Now that we have all the methods ready, let's test it and see if everything is working. Take a look at the code below.<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-Gg6JRxYkW0k/XTQEVgCPrBI/AAAAAAAAguA/Exq-3fqSMXM_ieClq2IQjMenMYixkACYwCEwYBhgL/s1600/digsignwithjava_main.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="339" data-original-width="1010" src="https://1.bp.blogspot.com/-Gg6JRxYkW0k/XTQEVgCPrBI/AAAAAAAAguA/Exq-3fqSMXM_ieClq2IQjMenMYixkACYwCEwYBhgL/s1600/digsignwithjava_main.png" /></a></div><br /></div><div><img src="blob:https://draft.blogger.com/2dd8af36-f251-4b30-847a-85116ff06df7" /><br />As can be seen above, I tried to perform signing to a string "Hello Digital Signing with Java". The keypair is to be generated using <b>RSA-2048</b> and the signing algorithm will be <b>SHA256withRSA</b>. By now, you should have noticed that the signing algorithm is the combination of the hashing and asymmetric-key algorithm, like what I have mentioned above.</div><div><br /></div><div>The flow is simple to follow. We generate the keypair first by calling the <b>generateKeyPair</b>&nbsp;and passing in all the required parameters. If key generation is successful, we will then proceed with the signing. Again, if signing is successful, we then proceed with verification.</div><div><br /></div><div>Let's run the application and see what's the output.</div><div><blockquote class="tr_bq"><i><b><span style="font-size: x-small;">Signature: I6NfpcLSd4jTyx+GMFHKxMpnK03M0N1DoCD5eq8/0yO9qi72isfhBvBjAll0DWbdLXsJdp0Fy4CifEcgrJMmjbbyR0lMg2vQzUuOJdudvLWFN4lJsN2rvIE3bD8pCvpdFio8M4cZlkGqO4MAp59xdSIYNTs9FBmk2e2WAPeSGKiC3AysdAn04Ctn37g1jDyC5RPCzZN/JGxma8TIFaBhW30JWo/inc5FnaqQ/D93L5N845RDFv175Lc6josOe6GlJoznmhxK7GyeilwZSg9PVHjTJIhFWmI3mASSRIsMalK8jKXWUZi8GILrMxJEGN5v1svID9RcQkhpW/ktyEf+tQ==<br />Now verifying...<br />Result: true</span></b></i></blockquote></div><div>Now, you can see that we have successfully generate the digital signature, which is then printed in base64 encoded format. The verification is as well successful. This proves that the data has not been tampered.</div><div><br /></div><div>Now, let's see what happen if we change the code to be like below.<br /><img src="blob:https://draft.blogger.com/327152be-14e5-423f-8748-74bd8804544d" /><br /><br /></div><div>Instead of just sending <b>TO_BE_SIGNED</b>&nbsp;to the verify function, I sent <b>TO_BE_SIGNED + "noise"</b>&nbsp;instead. This will change the plain text from "Hello Digital Signing with Java" to "Hello Digital Signing with Javanoise".</div><div><br /></div><div>Here is the output of the application now.</div><div><blockquote class="tr_bq"><span style="font-size: x-small;"><b>Signature: MLU+sWv0a8m2LSXzqnmjTQbcy89T3W7fn1n1W+qbxWmqu7eZoh6MSkwEZtZ0Vc9XIKRNjKI7Alm8+mMYYc0oqGk2favaHulUu77cFdSOn0xtJykqS4mFWplpUbZOmSFSop2slIvwpNE6vWxAUFd8T6Dt+041JCThiu5eq1VLmnHdGQB4SG8bOvxea2xH5ajXGX33au4m/Pn6TILmE+5JkRvSdCzwHsfONJ//RqcinHYWlcYOTTp+jqKJZL2FzHPE5EJoTg/8shmqFow0pFuiFXcAbuVaDfQ5U+4RiUyBTzp6TSjiQiNTRfEKKSTuP9A2ayegr5D9v5PNrwlT3U1Qtg==</b><b>Now verifying...</b><b>Result: false</b></span></blockquote></div><div>You can see above that the verification result now is <b>false</b>. This proves that the data has been tampered.</div><div><br /></div><h2>Conclusion</h2><div>Digital signing is very important to ensure data integrity and non-repudiation. This can be easily achieved with Java programming language using a few simple steps that we have discussed above. Hope this post helps.</div><div><br /></div><div>Source code for this post is available on GitHub as well:&nbsp;<a href="https://github.com/handracs2007/digitalsigning">https://github.com/handracs2007/digitalsigning</a>.</div><div><br /></div><div>Cheers</div></div>